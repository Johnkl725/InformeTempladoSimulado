\documentclass{article}
\usepackage{tocbibind} % Paquete para incluir el índice en el contenido
\usepackage{listings} % Paquete para incluir código fuente
\usepackage{xcolor} % Paquete para definir colores

\begin{document}

\title{
Facultad de Ingeniería de Sistemas e Informática\\
E.A.P de Ingeniería de Sistemas e Informática\\
\vspace{1cm}
TRABAJO GRUPAL\\
\vspace{1cm}
GRUPO N°3\\
\vspace{1cm}
Curso: Investigación Operativa\\
Docente: Cubas Becerra, Richard Javier\\
\vspace{1cm}
Integrantes:\\
Aldana Chipana, Mauricio \hfill [22200164]\\
Castillo Reupo, John \hfill [22200117]\\
Escribas Alan, Daniel \hfill [22200057]\\
Espíritu Unsihuay, Erika Milagros \hfill [22200170]\\
Valdiviezo Goicochea, Wisner \hfill [22200217]\\
\vspace{1cm}
Lima, Perú\\
2024
}
\date{}

\maketitle
\newpage % Comando para empezar una nueva página después del título

\tableofcontents % Comando para generar el índice
\newpage % Comando para empezar una nueva página después del índice

\section{Introducción al Templado Simulado}
El templado simulado es un algoritmo de optimización inspirado en el proceso de enfriamiento de metales. Este método es utilizado para encontrar soluciones aproximadas a problemas de optimización complejos.

\section{Funcionamiento del Algoritmo}
El algoritmo de templado simulado se basa en la analogía con el enfriamiento de metales. A continuación se presenta un modelo matemático que describe su funcionamiento:

\begin{equation}
P(E) = \exp\left(-\frac{\Delta E}{kT}\right)
\end{equation}

Donde:
\begin{itemize}
    \item \( P(E) \) es la probabilidad de aceptar una solución peor.
    \item \( \Delta E \) es el cambio en la energía (o costo) de la solución.
    \item \( k \) es una constante de Boltzmann.
    \item \( T \) es la temperatura.
\end{itemize}

El algoritmo comienza con una temperatura alta que se va reduciendo gradualmente. En cada iteración, se generan soluciones vecinas y se aceptan o rechazan basándose en la probabilidad \( P(E) \).

\section{Parámetros del Algoritmo}
Los parámetros clave del algoritmo de templado simulado incluyen:
\begin{itemize}
    \item Temperatura inicial (\( T_0 \))
    \item Tasa de enfriamiento (\( \alpha \))
    \item Número de iteraciones por temperatura
\end{itemize}

Estos parámetros deben ser ajustados cuidadosamente para obtener un buen rendimiento del algoritmo.

\section{Ventajas y Limitaciones}
\subsection{Ventajas}
\begin{itemize}
    \item Capacidad para escapar de óptimos locales.
    \item Flexibilidad para ser aplicado a una amplia variedad de problemas.
\end{itemize}

\subsection{Limitaciones}
\begin{itemize}
    \item Sensibilidad a la elección de parámetros.
    \item Puede ser computacionalmente costoso para problemas muy grandes.
\end{itemize}

\section{Caso Aplicativo}
Para ilustrar el uso del templado simulado, consideremos un problema de optimización en la investigación operativa, como la optimización de rutas de transporte. El objetivo es encontrar rutas eficientes que minimicen el costo total de transporte, considerando restricciones como la capacidad de los vehículos y las ventanas de tiempo de entrega.

El problema de optimización de rutas de transporte (Vehicle Routing Problem, VRP) es un problema clásico en la investigación operativa. En este problema, un conjunto de vehículos debe recoger y entregar bienes a un conjunto de clientes, minimizando el costo total de transporte. Las restricciones incluyen la capacidad de los vehículos y las ventanas de tiempo en las que las entregas deben realizarse.

El algoritmo de templado simulado puede ser utilizado para encontrar soluciones aproximadas a este problema. A continuación, se presenta una implementación en Python del algoritmo de templado simulado para resolver el VRP.

\lstset{language=Python, 
        basicstyle=\ttfamily\footnotesize, 
        keywordstyle=\color{blue}, 
        stringstyle=\color{red}, 
        commentstyle=\color{green}, 
        showstringspaces=false, 
        numbers=left, 
        numberstyle=\tiny\color{gray}, 
        breaklines=true, 
        frame=single, 
        captionpos=b}

\begin{lstlisting}
import math
import random

# Funcion de costo (distancia total de la ruta)
def calculate_cost(route, distance_matrix):
    cost = 0
    for i in range(len(route) - 1):
        cost += distance_matrix[route[i]][route[i + 1]]
    cost += distance_matrix[route[-1]][route[0]]  # Regresar al punto de inicio
    return cost

# Generar una solucion vecina
def generate_neighbor(route):
    new_route = route[:]
    i, j = random.sample(range(len(route)), 2)
    new_route[i], new_route[j] = new_route[j], new_route[i]
    return new_route

# Algoritmo de templado simulado
def simulated_annealing(distance_matrix, initial_temp, cooling_rate, num_iterations):
    current_route = list(range(len(distance_matrix)))
    random.shuffle(current_route)
    current_cost = calculate_cost(current_route, distance_matrix)
    best_route = current_route[:]
    best_cost = current_cost
    temperature = initial_temp

    for _ in range(num_iterations):
        new_route = generate_neighbor(current_route)
        new_cost = calculate_cost(new_route, distance_matrix)
        delta_cost = new_cost - current_cost

        if delta_cost < 0 or random.random() < math.exp(-delta_cost / temperature):
            current_route = new_route
            current_cost = new_cost

            if current_cost < best_cost:
                best_route = current_route
                best_cost = current_cost

        temperature *= cooling_rate

    return best_route, best_cost

# Ejemplo de uso
distance_matrix = [
    [0, 2, 9, 10],
    [1, 0, 6, 4],
    [15, 7, 0, 8],
    [6, 3, 12, 0]
]

initial_temp = 1000
cooling_rate = 0.99
num_iterations = 10000

best_route, best_cost = simulated_annealing(distance_matrix, initial_temp, cooling_rate, num_iterations)
print("Mejor ruta:", best_route)
print("Costo de la mejor ruta:", best_cost)
\end{lstlisting}

Este código proporciona una base para implementar el algoritmo de templado simulado en Python. Puedes adaptarlo y expandirlo según tus necesidades específicas.

\end{document}